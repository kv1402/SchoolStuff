/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
    /** A reference to the GUI interface */
    private Gui gui;
    /** The queue of processes waiting to use the CPU */
    private Queue cpuQueue;
    /** The process that is currently using the CPU */
    private Process activeProcess;
    /** A reference to the statistics collector */
    private Statistics statistics;
    /** The maximum time that a process can use the CPU "in one go". Also
      referred to as the Round Robin time quant. */
    private long maxCpuTime;

    /**
     * Creates a new CPU with the given parameters.
     * @param gui			A reference to the GUI interface.
     * @param cpuQueue		The CPU queue to be used.
     * @param maxCpuTime	The Round Robin time quant to be used.
     * @param statistics	A reference to the statistics collector.
     */
    public Cpu(Gui gui, Queue cpuQueue, long maxCpuTime, Statistics statistics) {
        this.gui = gui;
        this.cpuQueue = cpuQueue;
        this.maxCpuTime = maxCpuTime;
        this.statistics = statistics;
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     * @param p		The process to be added to the CPU queue.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
        cpuQueue.insert(p);
        // If the cpu was idle, call switchProcess to activate the newly arrived process
        if(activeProcess == null)
            return switchProcess(clock);
        else
            return null;
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
        if(activeProcess != null) {
            // If the queue is empty the active process is allowed to continue
            if(!cpuQueue.isEmpty()) {
                // Put the active process at the end of the queue
                activeProcess.leftCpu(clock);
                cpuQueue.insert(activeProcess);
                // Switch in a new process from the cpu queue
                activeProcess = (Process)cpuQueue.removeNext();
                activeProcess.enteredCpu(clock);
                gui.setCpuActive(activeProcess);
                // Update statistics
                statistics.nofProcessSwitches++;
            }
        }
        else {
            // No active process, switch in a process if the queue is non-empty
            if(!cpuQueue.isEmpty()) {
                activeProcess = (Process)cpuQueue.removeNext();
                activeProcess.enteredCpu(clock);
                gui.setCpuActive(activeProcess);
            }
        }
        // Figure out what to return
        if(activeProcess != null)
            return activeProcess.getNextEvent(clock, maxCpuTime);
        else
            return null;
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return	The event generated by the process switch, or null if no new
     *			process was switched in.
     */
    public Event activeProcessLeft(long clock) {
        activeProcess = null;
        gui.setCpuActive(null);
        return switchProcess(clock);
    }

    /**
     * Returns the process currently using the CPU.
     * @return	The process currently using the CPU.
     */
    public Process getActiveProcess() {
        return activeProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     * @param timePassed	The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
        if (activeProcess != null) {
            activeProcess.cpuTimePassed(timePassed);
            statistics.totalBusyCpuTime += timePassed;
        }
        statistics.cpuQueueLengthTime += cpuQueue.getQueueLength()*timePassed;
        if(cpuQueue.getQueueLength() > statistics.cpuQueueLargestLength) {
            statistics.cpuQueueLargestLength = cpuQueue.getQueueLength();
        }
    }
}
